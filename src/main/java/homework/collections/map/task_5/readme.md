Реализация LRU кэша (LRU Cache Implementation)

Реализуй кэш, который использует алгоритм LRU (Least Recently Used) для вытеснения элементов.
LRU-кэш хранит ограниченное количество элементов и вытесняет элемент,
который дольше всего не использовался, когда требуется добавить новый элемент, а кэш уже заполнен.

Требования:

- Посмотри [How to Implement LRU Cache in Java](https://www.baeldung.com/java-lru-cache)
- Используй комбинацию LinkedHashMap и DoublyLinkedList:
    - LinkedHashMap<Key, Node<Key, Value>>:
      *Для быстрого доступа к элементам кэша по ключу.*
      *LinkedHashMap сохраняет порядок вставки элементов, что полезно для отслеживания “последнего использования”*
    - DoublyLinkedList<Node<Key, Value>>:
      *Для хранения элементов в порядке их использования (от самых недавно использованных к самым давно
      использованным).*
      *DoublyLinkedList обеспечивает эффективное перемещение элементов в начало списка при доступе.*
- Создай класс Node<Key, Value>:
    - Представляет элемент кэша (ключ, значение, указатели на предыдущий и следующий элементы в двусвязном списке)
- Работа с кэшем (создай для кэша отдельный класс):
    - get(Key key):
      - Если элемент с ключом key есть в кэше:
      - Перемести элемент в начало двусвязного списка (чтобы отметить его как самый недавно использованный)
      - Верни значение элемента
      - Если элемента нет в кэше, верни null (или выброси исключение)
    - put(Key key, Value value):
        - Если элемент с ключом key уже есть в кэше:
            - Обнови значение элемента
            - Перемести элемент в начало двусвязного списка
        - Если элемента нет в кэше:
            - Создай новый элемент
            - Добавь элемент в начало двусвязного списка
            - Добавь элемент в LinkedHashMap
        - Если размер кэша превышает максимальный размер:
            - Удали последний элемент из двусвязного списка (самый давно использованный)
            - Удали элемент из LinkedHashMap.